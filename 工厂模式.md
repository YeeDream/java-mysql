1.简单工厂模式（静态工厂模式）

(1)定义：简单工厂模式专门负责定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
       
(2)结构
        
![image](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%872.png) 

(3)优点：
     
    ①实现了对象创建和使用的分离；
              
    ②客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可；
              
    ③通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性
       
(4)缺点：
   
    ①职责过重
            
    ②增加系统中类的个数

    ③系统扩展困难

    ④工厂角色无法形成基于继承的等级结构
      
(5)适用场景
 
    ①工厂类负责创建的对象比较少
                   
    ②客户端只知道传入工厂类的参数，对于如何创建对象不关心

2.工厂方法模式
  
(1)定义：工厂父类负责创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
  
(2)结构：

![image](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%873.png)

(3)优点：
    
    ①子类提供挂钩。基类为工厂方法提供缺省实现，子类可以重写新的实现，也可以继承父类的实现。
    
    ②屏蔽产品类。产品类的实现如何变化，调用者都不需要关心，只需关心产品的接口，只要接口保持不变，系统中的上层模块就不会发生变化。
         
    ③典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不需要关心，符合迪米特法则，符合依赖倒转原则，符合里氏替换原则。
    
    ④多态性：客户代码可以做到与特定应用无关，适用于任何实体类
  
(4)缺点：需要Createor和相应的子类作为factory method的载体，如果模型确实需要createor和子类存在，则很好；否则的话，需要增加一个类层次。
 
 (5)适用场景：
    
    ①客户端不知道它所需要对象的类
    
    ②抽象工厂类通过其子类来指定创建哪个对象


3.抽象工厂模式
  
(1)定义：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
  
(2)结构：
      
![image](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%874.png)
  
(3)优点：
    
    ①隔离了具体类的生成
    
    ②能够保证客户端始终只使用同一个产品族中的对象
    
    ③增加新的产品族很方便，符合开闭原则
  
(4)缺点：增加新的产品等级结构麻烦，违背了开闭原则
 
 (5)适用场景：
  
    ①不应当依赖于产品类实例如何被创建、组合和表达的细节
    
    ②每次只使用其中某一产品族
    
    ③属于同一个产品族的产品将在一起使用
               
    ④产品等级结构稳定
